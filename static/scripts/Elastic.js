const x=512,y=8,R=200,D=.999;function p(e,s){return Math.random()*(s-e)+e}function S(e,s,t,i,h,o){const c=e-i,a=s-h;return c*c+a*a<(t+o)*(t+o)}function U(e,s,t,i,h){const o=e-t,c=s-i;return o*o+c*c<h*h}function k(e,s){return{x:s.x-e.x,y:s.y-e.y}}function b(e){return Math.sqrt(e.x*e.x+e.y*e.y)}function E(e){const s=b(e);return{x:e.x/s,y:e.y/s}}function f(e,s){return e.x*s.x+e.y*s.y}function F(e,s){return{x:e.x*s,y:e.x*s}}export class Elastic{constructor(s){this.mouse={x:0,y:0,isLeftDown:!1,isRightDown:!1,isLeftUp:!0,isRightUp:!0},this.prevMouse={...this.mouse},this.pauseUpdate=!1,this.selected=-1,this.radiuses=[],this.colors=[],this.positions=[],this.velocities=[],this.accelerations=[],this.collidingPairs=[],this.mFrameTime=0,this.frameTimes=[],this.lastTime=0,this.currentTime=0,this.animationID=-1,this.resolution=1,this.canvas=document.createElement("canvas"),this.canvas.style.width="100%",this.canvas.style.height="100%",s.appendChild(this.canvas);const t=this.canvas.getContext("2d");if(t)this.context=t;else throw new Error("Error creating 2D context");this.resize()}async start(){await this.init(),this.loop(-16)}async stop(){cancelAnimationFrame(this.animationID)}destroy(){this.canvas.remove()}async init(){for(let s=0;s<x;s++)this.positions.push({x:Math.random()*this.width,y:Math.random()*this.height}),this.velocities.push({x:p(-1,1)*R,y:p(-1,1)*R}),this.accelerations.push({x:0,y:0}),this.radiuses.push(Math.floor(p(5,16))),this.colors.push("#ffffff")}update(s){this.collidingPairs=[];for(let t=0;t<x&&!this.pauseUpdate;t++)this.velocities[t].x*=D,this.velocities[t].y*=D,this.velocities[t].x+=this.accelerations[t].x*s,this.velocities[t].y+=this.accelerations[t].y*s,this.positions[t].x+=this.velocities[t].x*s,this.positions[t].y+=this.velocities[t].y*s,this.positions[t].x-this.radiuses[t]<0&&(this.positions[t].x=this.width-this.radiuses[t]),this.positions[t].x+this.radiuses[t]>this.width&&(this.positions[t].x=this.radiuses[t]),this.positions[t].y-this.radiuses[t]<0&&(this.positions[t].y=this.height-this.radiuses[t]),this.positions[t].y+this.radiuses[t]>this.height&&(this.positions[t].y=this.radiuses[t]),this.velocities[t].x*this.velocities[t].x+this.velocities[t].y*this.velocities[t].y<.01&&(this.velocities[t].x=0,this.velocities[t].y=0);for(let t=0;t<x;t++){const{x:i,y:h}=this.positions[t];(this.mouse.isLeftDown&&!this.prevMouse.isLeftDown||this.mouse.isRightDown&&!this.prevMouse.isRightDown)&&U(this.mouse.x,this.mouse.y,i,h,this.radiuses[t])&&this.selected===-1&&(this.selected=t);for(let o=0;o<x;o++){if(t===o)continue;const{x:c,y:a}=this.positions[o];if(S(i,h,this.radiuses[t],c,a,this.radiuses[o])){const n=b({x:c-i,y:a-h}),r=.5*(n-this.radiuses[t]-this.radiuses[o]);this.collidingPairs.push({first:t,second:o}),this.positions[t].x-=r*(i-c)/n,this.positions[t].y-=r*(h-a)/n,this.positions[o].x+=r*(i-c)/n,this.positions[o].y+=r*(h-a)/n}}}for(let t=0;t<this.collidingPairs.length;t++){const{first:i,second:h}=this.collidingPairs[t],o=this.positions[i],c=this.positions[h],a=k(o,c),n=E(a),r={x:-n.y,y:n.x},d=this.velocities[i],m=this.velocities[h],v=f(d,r),g=f(m,r),w=f(d,n),P=f(m,n),l=this.radiuses[i],u=this.radiuses[h],T=(w*(l-u)+2*u*P)/(l+u),M=(P*(u-l)+2*l*w)/(l+u);d.x=r.x*v+n.x*T,d.y=r.y*v+n.y*T,m.x=r.x*g+n.x*M,m.y=r.y*g+n.y*M}if(this.selected!==-1&&this.mouse.isLeftDown)this.positions[this.selected].x=this.mouse.x,this.positions[this.selected].y=this.mouse.y;else if(this.selected!==-1&&this.mouse.isRightUp){const{x:t,y:i}=this.positions[this.selected],h=t-this.mouse.x,o=i-this.mouse.y;this.velocities[this.selected].x=h,this.velocities[this.selected].y=o,this.selected=-1}if(this.resize(),this.frameTimes.length>=y){let t=0;for(let i=0;i<y;i++)t+=this.frameTimes[i];this.mFrameTime=t/y,this.frameTimes=[]}else this.frameTimes.push(s);this.prevMouse={...this.mouse}}draw(s){this.context.clearRect(0,0,this.width,this.height);for(let t=0;t<x;t++){const{x:i,y:h}=this.positions[t],o=this.radiuses[t];this.context.beginPath(),this.context.arc(i,h,o,0,2*Math.PI),U(this.mouse.x,this.mouse.y,i,h,o)?this.context.strokeStyle="#ff0080":this.context.strokeStyle=this.colors[t],this.context.stroke(),this.context.closePath(),this.context.beginPath(),this.context.strokeStyle="#00ff99",this.context.moveTo(i,h),this.context.lineTo(i+this.velocities[t].x*s*this.radiuses[t],h+this.velocities[t].y*s*this.radiuses[t]),this.context.stroke(),this.context.closePath()}for(let t=0;t<this.collidingPairs.length;t++){const{first:i,second:h}=this.collidingPairs[t],{x:o,y:c}=this.positions[i],{x:a,y:n}=this.positions[h];this.context.beginPath(),this.context.moveTo(o,c),this.context.lineTo(a,n),this.context.strokeStyle="#ff8c00",this.context.stroke(),this.context.closePath()}if(this.selected!==-1&&this.mouse.isRightDown){const{x:t,y:i}=this.positions[this.selected];this.context.beginPath(),this.context.moveTo(t,i),this.context.lineTo(this.mouse.x,this.mouse.y),this.context.strokeStyle="#ff1c42",this.context.stroke(),this.context.closePath()}this.context.fillStyle="white",this.context.font=`${12*devicePixelRatio}px monospace`,this.context.fillText(`${this.mFrameTime.toFixed(3)} ms, ${(1/this.mFrameTime).toFixed(1)} fps`,10*devicePixelRatio,(14+10)*devicePixelRatio),this.context.fillText(`sim: ${this.pauseUpdate?"pause":"play"}`,10*devicePixelRatio,(14+10+14)*devicePixelRatio)}loop(s){this.currentTime=s;const t=(this.currentTime-this.lastTime)/1e3;this.update(t),this.draw(t),this.lastTime=this.currentTime,this.animationID=requestAnimationFrame(this.loop.bind(this))}get width(){return this.canvas.width}get height(){return this.canvas.height}get ratio(){return this.canvas.width/this.canvas.height}onMouseMove(s){this.mouse.x=s.clientX,this.mouse.y=s.clientY}onMouseDown(s){this.mouse.x=s.clientX,this.mouse.y=s.clientY,s.button===0&&(this.mouse.isLeftDown=!0,this.mouse.isLeftUp=!1),s.button===2&&(this.mouse.isRightDown=!0,this.mouse.isRightUp=!1)}onMouseUp(s){this.mouse.x=s.clientX,this.mouse.y=s.clientY,s.button===0&&(this.mouse.isLeftDown=!1,this.mouse.isLeftUp=!0),s.button===2&&(this.mouse.isRightDown=!1,this.mouse.isRightUp=!0)}onContextMenu(s){s.preventDefault()}onKeyDown(s){}onKeyUp(s){}onKeyPress(s){s.key===" "&&(this.pauseUpdate=!this.pauseUpdate)}resize(){const s=Math.round(this.canvas.clientWidth*devicePixelRatio*this.resolution),t=Math.round(this.canvas.clientHeight*devicePixelRatio*this.resolution);(this.width!=s||this.height!=t)&&(this.canvas.width=s,this.canvas.height=t)}}
